# 进程
  - 状态图：上网查，或者查书
  - 比较重要的几个状态：
  1. 运行态
  2. 就绪态
  3. 阻塞态

  - 挂起：挂起是为了减少物理内存的消耗，将就绪态和阻塞态的进程挂在外存上
  - 阻塞挂起：将进程挂起到外存，等待某个事件发生
  - 就绪挂起：将进程挂起到外存，但只要被激活，立马进入内存



### 描述进程的数据结构
  - PCB（Process Control Block）
  - PCB是进程的唯一标识：里面包含了很多信息，例如CPU抢占优先级，进程所处状态，进程标识符（标识自己），用户标识符（属于那个用户）


  - PCB是如何组织的？
  - 通过链表，把相同状态的PCB组成一个队列
  - 例如：就绪队列，阻塞PCB队列

### 进程上下文切换
  - 进程的上下⽂切换不仅包含了虚拟内存、栈、全局变量等⽤户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源
  - 进程的上下文是存储在PCB当中的，所以当切换进程时，会将当前的上下文保存到当前进程PCB中，然后加载新进程时，从新进程PCB中读出该进程上下文信息，使得新进程继续执行


# 线程
  - 线程是调度的基本单位，⽽进程则是资源拥有的基本单位
  - 当进程只有⼀个线程时，可以认为进程就等于线程
  - 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源，这些资源在上下⽂切换时是不需要修改的

  - 第三条说明线程的上下文切换时间成本比进程低


### 线程上下文切换
  - 2 个线程不在同一个进程内，线程上下文切换 == 进程上下文切换
  - 2 个线程在同一个进程内，线程上下文切换只需要切换私有数据和栈，虚拟内存和共有数据的内容不需要保存切换




# 互斥
  - 当两个线程访问同一个资源时，会产生竞争现象；
  - 产生竞争的代码块，我们称为临界区；
  - 我们希望临界区是互斥的，就是一个线程访问完，下一个线程才可以接着访问；


# 同步
  - 有时候并发/并行执行程序时，我们希望不同线程之间可以互相合作，完成同一个任务；
  - 我们把线程分为读进程和写进程，那么写进程就必须等待读进程完毕，才执行；
  - 所以我们把这种进程之间互相等待，互相制约的关系叫做进程同步



# 实现进程互斥与同步
  - 锁与信号量
  - 信号量比锁强一些，可以实现进程同步

