# 虚拟内存
### 运行方式:
  - CPU--->虚拟内存--->MMU(内存管理单元)--->物理内存

  - 所以程序所面对的是内存是虚拟内存；


### MMU怎么管理虚拟内存与物理内存之间的关系？
  - 两种方式：1.内存分段；2.内存分页
  - 内存分段的缺点：
  1. 内存碎片（内部内存碎片和外部内存碎片）
  2. 内存交换效率低（可能会频繁出现内存与磁盘之间的交互）（这一点是因为内存碎片的存在，要将原进程杀掉，释放内存空间，再将程序重新加载进内存中）

  - 内存分段的好处是可以使用连续的内存空间


### 内存分页
  - 将虚拟内存和物理内存分页，页的大小为4KB，由MMU管理页表将虚拟地址映射到物理地址
  - 内存分页的好处：
  1. 首先解决了内存碎片的问题
  2. 提高了内存交换效率低的问题（应用局部性原理，对于不常用的页可以将其先放回磁盘中）


#### 多级页表（局部性原理）
  - 只有一级页表：每个页表项需要4 Byte 来存储，每个进程有4 Gb 的虚拟内存大小，页的大小是4 Kb，有2^20 那么多的页数，那么一个进程的页表所占内存的大小就是4 Mb；
  - 这样计算好像不多，但是如果多进程并发时，例如100个进程，那么所占内存大小就是400 Mb；

  - 解决方案：多级页表
  - 将页表在分页，使用二级页表结构；
  - 将每1024个页表项组成 1  页（恰好是 4 Kb） ， 将页表分成1024 个页；
  - 然后一级页表只需要记录这 1024 个页的地址即可， 
  - 综上所述：
  1. 一级页表所占内存：4 Kb；
  2. 二级页表所占内存：4 Mb；

这样操作的话，页表所占内存不是变得更多了吗？
  - 局部性原理：我们在虚拟内存中的指令与数据需要使用时，才去映射为物理内存，生成二级页表（由于局部性原理的存在，一般只会有20%的二级页表背生成）
  - 也就是说 平均使用内存量为：0.004 + 4 * 0.2 = 0.804 Mb
  - 相比于一级页表所占内存减少了不少



#### 64bit系统
  - 对于64bit系统，采用的是四级页表结构



### TLB
  - 多级页表解决了空间的问题，但是多级页表的存在，降低了地址转换之间的效率问题
  - 在CPU中加入一个cache ， TLB（快表），存储最常访问的页



### 段页式地址转换
  - 分段与分页不是相对的

## linux采用的方式
  - 页式存储
  - 但是不可避免的用了段式














